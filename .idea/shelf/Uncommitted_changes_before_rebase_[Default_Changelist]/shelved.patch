Index: app/src/main/java/com/gthr/gthrcollect/data/repository/ProfileRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gthr.gthrcollect.data.repository\r\n\r\nimport android.net.Uri\r\nimport com.google.firebase.database.ktx.database\r\nimport com.google.firebase.firestore.ktx.firestore\r\nimport com.google.firebase.ktx.Firebase\r\nimport com.google.firebase.storage.ktx.storage\r\nimport com.gthr.gthrcollect.GthrCollect\r\nimport com.gthr.gthrcollect.data.remote.fetchData\r\nimport com.gthr.gthrcollect.model.State\r\nimport com.gthr.gthrcollect.model.domain.*\r\nimport com.gthr.gthrcollect.model.mapper.*\r\nimport com.gthr.gthrcollect.model.network.firebaserealtimedb.*\r\nimport com.gthr.gthrcollect.utils.constants.CloudFunctions\r\nimport com.gthr.gthrcollect.utils.constants.FirebaseRealtimeDatabase\r\nimport com.gthr.gthrcollect.utils.constants.FirebaseStorage\r\nimport com.gthr.gthrcollect.utils.enums.ProductType\r\nimport com.gthr.gthrcollect.utils.extensions.getUserCollectionId\r\nimport com.gthr.gthrcollect.utils.extensions.updateCollectionInfoModelData\r\nimport com.gthr.gthrcollect.utils.getProductType\r\nimport com.gthr.gthrcollect.utils.logger.GthrLogger\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.flow.catch\r\nimport kotlinx.coroutines.flow.flow\r\nimport kotlinx.coroutines.flow.flowOn\r\nimport kotlinx.coroutines.tasks.await\r\n\r\nclass ProfileRepository {\r\n    private val mFirestore = Firebase.firestore\r\n    private val mFirebaseRD = Firebase.database.reference\r\n    private val mStorageRef = Firebase.storage.reference\r\n\r\n    fun fetchUserProfileData(collectionId: String) =\r\n        flow<State<CollectionInfoDomainModel>> {\r\n            emit(State.loading())\r\n            val collectionInfo = mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL)\r\n                .child(collectionId).get().await().getValue(CollectionInfoModel::class.java)\r\n\r\n            //If the user is Logged in user, then save the data\r\n            if (collectionId == GthrCollect.prefs?.getUserCollectionId())\r\n                collectionInfo?.let {\r\n                    GthrCollect.prefs?.updateCollectionInfoModelData(it.toCollectionInfoDomainModel())\r\n                }\r\n\r\n            emit(State.Success(collectionInfo!!.toCollectionInfoDomainModel()))\r\n        }.catch {\r\n            // If exception is thrown, emit failed state along with message.\r\n            emit(State.failed(it.message.toString()))\r\n        }.flowOn(Dispatchers.IO)\r\n\r\n    fun insertCollectionInfoInRD(collectionInfoModel: CollectionInfoModel) =\r\n        flow<State<String>> {\r\n            emit(State.loading())\r\n\r\n            val data = mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL)\r\n                .child(GthrCollect.prefs?.userInfoModel?.collectionId.toString())\r\n                .child(FirebaseRealtimeDatabase.ABOUT)\r\n            data.setValue(collectionInfoModel.about).await()\r\n\r\n            emit(State.success(data.key.toString()))\r\n\r\n        }.catch {\r\n            // If exception is thrown, emit failed state along with message.\r\n            emit(State.failed(it.message.toString()))\r\n            GthrLogger.d(\"Faileeed\", it.message.toString())\r\n        }.flowOn(Dispatchers.IO)\r\n\r\n    fun uploadProfilePic(uri: Uri) = flow<State<Boolean>> {\r\n        emit(State.loading())\r\n\r\n        // upload image to Fb storage\r\n        val ref = mStorageRef.child(FirebaseStorage.PROFILE_IMAGE)\r\n            .child(GthrCollect.prefs?.userInfoModel?.collectionId.toString())\r\n        ref.putFile(uri).await()\r\n\r\n        // converting storage path to image download URL and save to Rd collection model\r\n        val imageUrl = ref.downloadUrl.await()\r\n        mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL)\r\n            .child(GthrCollect.prefs?.userInfoModel?.collectionId.toString())\r\n            .child(FirebaseRealtimeDatabase.PROFILE_URL_KEY).setValue(imageUrl.toString()).await()\r\n\r\n        emit(State.success(true))\r\n\r\n    }.catch {\r\n        // If exception is thrown, emit failed state along with message.\r\n        emit(State.failed(it.message.toString()))\r\n    }.flowOn(Dispatchers.IO)\r\n\r\n    fun fetchMyFollowing(collectionId: String) =\r\n        flow<State<List<CollectionInfoDomainModel>>> {\r\n            emit(State.loading())\r\n\r\n            val followingData = mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL)\r\n                .child(collectionId)\r\n                .child(FirebaseRealtimeDatabase.FAVORITE_COLLECTION_LIST).get().await()\r\n\r\n            val arrayList = mutableListOf<CollectionInfoDomainModel>()\r\n\r\n            if (followingData.hasChildren()) {\r\n                val followingList = followingData.value as List<String>\r\n\r\n                //Retrieve Following Users data with respect to its collection id\r\n                followingList.forEach { collectionId ->\r\n                    val collectionInfo: CollectionInfoDomainModel? =\r\n                        mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL)\r\n                            .child(collectionId).get().await()\r\n                            .getValue(\r\n                                CollectionInfoModel::class.java\r\n                            )?.toCollectionInfoDomainModel(collectionId)\r\n\r\n                    if (collectionInfo != null) {\r\n                        arrayList.add(collectionInfo)\r\n                    }\r\n                }\r\n            }\r\n\r\n            emit(State.Success(arrayList))\r\n        }.catch {\r\n            // If exception is thrown, emit failed state along with message.\r\n            emit(State.failed(it.message.toString()))\r\n            GthrLogger.e(\"Followers\", it.message.toString())\r\n\r\n        }.flowOn(Dispatchers.IO)\r\n\r\n    fun fetchMyFollowersList(collectionId: String) =\r\n        flow<State<List<CollectionInfoDomainModel>>> {\r\n\r\n            emit(State.loading())\r\n\r\n            val data = mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL)\r\n                .child(collectionId)\r\n                .child(FirebaseRealtimeDatabase.FOLLOWERS_LIST).get().await()\r\n\r\n            val arrayList = mutableListOf<CollectionInfoDomainModel>()\r\n\r\n            if (data.hasChildren()) {\r\n                val followingList = data.value as List<String>\r\n\r\n                followingList.forEach { collectionId ->\r\n\r\n                    val collectionInfo: CollectionInfoDomainModel? =\r\n                        mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL)\r\n                            .child(collectionId).get().await()\r\n                            .getValue(\r\n                                CollectionInfoModel::class.java\r\n                            )?.toCollectionInfoDomainModel(collectionId)\r\n\r\n                    GthrLogger.e(\"MyFollowers\", collectionId.toString())\r\n\r\n                    if (collectionInfo != null) {\r\n                        arrayList.add(collectionInfo)\r\n                    }\r\n                }\r\n            }\r\n            emit(State.Success(arrayList))\r\n\r\n        }.catch {\r\n            // If exception is thrown, emit failed state along with message.\r\n            emit(State.failed(it.message.toString()))\r\n            print(it.cause?.message)\r\n            GthrLogger.e(\"MyFollowers\", it.message.toString())\r\n\r\n        }.flowOn(Dispatchers.IO)\r\n\r\n    fun followToUser(collectionId: String) =\r\n        flow<State<String>> {\r\n            emit(State.loading())\r\n\r\n            val myCollectionId = GthrCollect.prefs?.getUserCollectionId().toString()\r\n            val otherUserFollowerLink =\r\n                mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL)\r\n                    .child(collectionId)\r\n                    .child(FirebaseRealtimeDatabase.FOLLOWERS_LIST)\r\n            val ourUserFollowingLink =\r\n                mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL)\r\n                    .child(myCollectionId)\r\n                    .child(FirebaseRealtimeDatabase.FAVORITE_COLLECTION_LIST)\r\n\r\n            // Retrieve follower list of other user\r\n            val otherUserFollowerList = otherUserFollowerLink.get().await()\r\n            //Create an empty follower list\r\n            val fList = mutableListOf<String>()\r\n            //Check if other user has a list, then add our collection Id to it\r\n            if (otherUserFollowerList.hasChildren()) {\r\n                fList.addAll(otherUserFollowerList.value as ArrayList<String>)\r\n            }\r\n            fList.add(myCollectionId)\r\n            //Update other user's follower List\r\n            otherUserFollowerLink.setValue(fList).await()\r\n\r\n\r\n            // Create an empty following list\r\n            val foList = mutableListOf<String>()\r\n            //Retrieve following list of our user\r\n            val ourFollowingList = ourUserFollowingLink.get().await()\r\n            //Check if our user has a list, then add other user's collection Id to it\r\n            if (ourFollowingList.hasChildren()) {\r\n                foList.addAll(ourFollowingList.value as ArrayList<String>)\r\n            }\r\n            foList.add(collectionId)\r\n            // updating our following List\r\n            ourUserFollowingLink.setValue(foList).await()\r\n\r\n            emit(State.success(\"Followed\"))\r\n\r\n        }.catch {\r\n            // If exception is thrown, emit failed state along with message.\r\n            emit(State.failed(it.message.toString()))\r\n            GthrLogger.d(\"Faileeed\", it.message.toString())\r\n        }.flowOn(Dispatchers.IO)\r\n\r\n    fun unFollowToUser(collectionId: String) =\r\n        flow<State<String>> {\r\n            emit(State.loading())\r\n\r\n            // Adding another user to my  followersList\r\n            val fList = mutableListOf<String>()\r\n            val myCollectionId = GthrCollect.prefs?.getUserCollectionId().toString()\r\n\r\n            // Retriving Follower's list\r\n            val getList = mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL)\r\n                .child(collectionId)\r\n                .child(FirebaseRealtimeDatabase.FOLLOWERS_LIST).get().await().value\r\n            fList.addAll(getList as ArrayList<String>)\r\n            fList.remove(myCollectionId)\r\n\r\n            // updating the List\r\n            mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL)\r\n                .child(collectionId)\r\n                .child(FirebaseRealtimeDatabase.FOLLOWERS_LIST).setValue(fList).await()\r\n\r\n            // Adding Me to  another user's to favoriteCollectionList\r\n            val foList = mutableListOf<String>()\r\n\r\n            // Retriving Following list\r\n            val favList = mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL)\r\n                .child(myCollectionId)\r\n                .child(FirebaseRealtimeDatabase.FAVORITE_COLLECTION_LIST).get().await().value\r\n\r\n            foList.addAll(favList as ArrayList<String>)\r\n            foList.remove(collectionId)\r\n\r\n            // updating the List\r\n            mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL)\r\n                .child(myCollectionId).child(FirebaseRealtimeDatabase.FAVORITE_COLLECTION_LIST)\r\n                .setValue(foList).await()\r\n\r\n            emit(State.success(\"Un-Followed\"))\r\n\r\n        }.catch {\r\n            // If exception is thrown, emit failed state along with message.\r\n            emit(State.failed(it.message.toString()))\r\n            GthrLogger.d(\"Faileeed\", it.message.toString())\r\n        }.flowOn(Dispatchers.IO)\r\n\r\n\r\n    fun getCollectionProduct(map : Map<String, CollectionItemModel>) = flow<State<List<ProductDisplayModel>>> {\r\n        val productList = mutableListOf<ProductDisplayModel>()\r\n        map.keys.forEach {\r\n            emit(State.loading())\r\n            val data = map[it]\r\n            val productType = data?.productType\r\n            val objectID = data?.objectID\r\n\r\n            when (getProductType(productType!!)) {\r\n                ProductType.MAGIC_THE_GATHERING -> {\r\n                    val data = getProductDetailsByObjectId<MTGDomainModel>(\r\n                        objectID!!,\r\n                        getProductType(productType)!!\r\n                    )\r\n                    data?.let {\r\n                        val prodDisplay = ProductDisplayModel(data)\r\n                        productList.add(prodDisplay)\r\n                    }\r\n                }\r\n                ProductType.YUGIOH -> {\r\n                    val data = getProductDetailsByObjectId<YugiohDomainModel>(\r\n                        objectID!!,\r\n                        getProductType(productType)!!\r\n                    )\r\n                    data?.let {\r\n                        val prodDisplay= ProductDisplayModel(data)\r\n                        productList.add(prodDisplay)\r\n                    }\r\n                }\r\n                ProductType.POKEMON ->{\r\n                    val data = getProductDetailsByObjectId<PokemonDomainModel>(\r\n                        objectID!!,\r\n                        getProductType(productType)!!\r\n                    )\r\n                    data?.let {\r\n                        val prodDisplay= ProductDisplayModel(data)\r\n                        productList.add(prodDisplay)\r\n                    }\r\n                }\r\n                ProductType.FUNKO -> {\r\n                    val data = getProductDetailsByObjectId<FunkoDomainModel>(\r\n                        objectID!!,\r\n                        getProductType(productType)!!\r\n                    )\r\n                    data?.let {\r\n                        val prodDisplay = ProductDisplayModel(data)\r\n                        productList.add(prodDisplay)\r\n                    }\r\n                }\r\n                ProductType.SEALED_POKEMON, ProductType.SEALED_YUGIOH, ProductType.SEALED_MTG -> {\r\n                    val data = getProductDetailsByObjectId<SealedDomainModel>(\r\n                        objectID!!,\r\n                        getProductType(productType)!!\r\n                    )\r\n                    data?.let {\r\n                        val prodDisplay = ProductDisplayModel(data)\r\n                        productList.add(prodDisplay)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        emit(State.success(productList))\r\n    }.catch {\r\n        // If exception is thrown, emit failed state along with message.\r\n        emit(State.failed(it.message.toString()))\r\n    }.flowOn(Dispatchers.IO)\r\n\r\n    suspend fun <T> getProductDetailsByObjectId(id: String, type: ProductType): T? {\r\n        var ref = mFirebaseRD\r\n        val networkModelType = when (type) {\r\n            ProductType.MAGIC_THE_GATHERING -> {\r\n                ref = ref.child(FirebaseRealtimeDatabase.MTG_MODEL)\r\n                MTGModel::class.java\r\n            }\r\n            ProductType.YUGIOH -> {\r\n                ref = ref.child(FirebaseRealtimeDatabase.YUGIOH_MODEL)\r\n                YugiohModel::class.java\r\n            }\r\n            ProductType.POKEMON -> {\r\n                ref = ref.child(FirebaseRealtimeDatabase.POKEMON_MODEL)\r\n                PokemonModel::class.java\r\n            }\r\n            ProductType.FUNKO -> {\r\n                ref = ref.child(FirebaseRealtimeDatabase.FUNKO_MODEL)\r\n                FunkoModel::class.java\r\n            }\r\n            ProductType.SEALED_POKEMON, ProductType.SEALED_YUGIOH, ProductType.SEALED_MTG -> {\r\n                ref = ref.child(FirebaseRealtimeDatabase.SEALED_MODEL)\r\n                SealedModel::class.java\r\n            }\r\n        }\r\n        val await = ref.orderByChild(FirebaseRealtimeDatabase.OBJECT_ID).equalTo(id).get().await()\r\n\r\n        if (await.childrenCount == 1L) {\r\n            val snapShot = await.children.iterator().next()\r\n            val productDetailsNetworkModel = snapShot.getValue(networkModelType)\r\n            val productDetailsDomainModel = when (type) {\r\n                ProductType.MAGIC_THE_GATHERING -> (productDetailsNetworkModel as MTGModel).toMTGDomainModel(\r\n                    snapShot.key ?: \"\"\r\n                )\r\n                ProductType.YUGIOH -> (productDetailsNetworkModel as YugiohModel).toYugiohDomainModel(\r\n                    snapShot.key ?: \"\"\r\n                )\r\n                ProductType.POKEMON -> (productDetailsNetworkModel as PokemonModel).toPokemonDomainModel(\r\n                    snapShot.key ?: \"\"\r\n                )\r\n                ProductType.FUNKO -> (productDetailsNetworkModel as FunkoModel).toFunkoDomainModel(\r\n                    snapShot.key ?: \"\"\r\n                )\r\n                ProductType.SEALED_POKEMON, ProductType.SEALED_YUGIOH, ProductType.SEALED_MTG -> (productDetailsNetworkModel as SealedModel).toSealedDomainModel(\r\n                    snapShot.key ?: \"\"\r\n                )\r\n            }\r\n            return productDetailsDomainModel as T\r\n        }\r\n        return null\r\n    }\r\n\r\n    fun fetchBidProducts(collectionId : String) = flow<State<List<ProductDisplayModel>>> {\r\n        // Emit loading state\r\n        emit(State.loading())\r\n\r\n        val data = hashMapOf(\r\n            CloudFunctions.COLLECTION_ID to (collectionId ?: \"\"),\r\n        )\r\n\r\n        GthrLogger.d(\"mayank\", data.toString())\r\n\r\n        val productData = fetchData<List<HashMap<String, String>>>(CloudFunctions.SEARCH_BIDS, data).await()\r\n        val productList = mutableListOf<ProductDisplayModel>()\r\n\r\n        productData.forEachIndexed { index, it ->\r\n            val objectID = productData[index][FirebaseRealtimeDatabase.ITEM_OBJECT_ID]\r\n            val productType = productData[index][FirebaseRealtimeDatabase.PRODUCT_TYPE]\r\n\r\n            when (getProductType(productType!!)) {\r\n                ProductType.MAGIC_THE_GATHERING -> {\r\n                    val data = getProductDetailsByObjectId<MTGDomainModel>(\r\n                        objectID!!,\r\n                        getProductType(productType)!!\r\n                    )\r\n                    data?.let {\r\n                        val prodDisplay = ProductDisplayModel(data)\r\n                        productList.add(prodDisplay)\r\n                    }\r\n                }\r\n                ProductType.YUGIOH -> {\r\n                    val data = getProductDetailsByObjectId<YugiohDomainModel>(\r\n                        objectID!!,\r\n                        getProductType(productType)!!\r\n                    )\r\n                    data?.let {\r\n                        val prodDisplay= ProductDisplayModel(data)\r\n                        productList.add(prodDisplay)\r\n                    }\r\n                }\r\n                ProductType.POKEMON ->{\r\n                    val data = getProductDetailsByObjectId<PokemonDomainModel>(\r\n                        objectID!!,\r\n                        getProductType(productType)!!\r\n                    )\r\n                    data?.let {\r\n                        val prodDisplay= ProductDisplayModel(data)\r\n                        productList.add(prodDisplay)\r\n                    }\r\n                }\r\n                ProductType.FUNKO -> {\r\n                    val data = getProductDetailsByObjectId<FunkoDomainModel>(\r\n                        objectID!!,\r\n                        getProductType(productType)!!\r\n                    )\r\n                    data?.let {\r\n                        val prodDisplay = ProductDisplayModel(data)\r\n                        productList.add(prodDisplay)\r\n                    }\r\n                }\r\n                ProductType.SEALED_POKEMON, ProductType.SEALED_YUGIOH, ProductType.SEALED_MTG -> {\r\n                    val data = getProductDetailsByObjectId<SealedDomainModel>(\r\n                        objectID!!,\r\n                        getProductType(productType)!!\r\n                    )\r\n                    data?.let {\r\n                        val prodDisplay = ProductDisplayModel(data)\r\n                        productList.add(prodDisplay)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit(State.success(productList))\r\n\r\n    }.catch {\r\n        // If exception is thrown, emit failed state along with message.\r\n        emit(State.failed(it.message.toString()))\r\n    }.flowOn(Dispatchers.IO)\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/gthr/gthrcollect/data/repository/ProfileRepository.kt b/app/src/main/java/com/gthr/gthrcollect/data/repository/ProfileRepository.kt
--- a/app/src/main/java/com/gthr/gthrcollect/data/repository/ProfileRepository.kt	(revision 5afe8ae07915a360cc92d45e0a46d20d1c6c84e4)
+++ b/app/src/main/java/com/gthr/gthrcollect/data/repository/ProfileRepository.kt	(date 1632406327081)
@@ -1,6 +1,7 @@
 package com.gthr.gthrcollect.data.repository
 
 import android.net.Uri
+import android.util.Log
 import com.google.firebase.database.ktx.database
 import com.google.firebase.firestore.ktx.firestore
 import com.google.firebase.ktx.Firebase
@@ -261,15 +262,16 @@
             val data = map[it]
             val productType = data?.productType
             val objectID = data?.objectID
+            val isForSale = data?.askRefKey!=null&&data?.askRefKey?.isNotEmpty()!!
 
             when (getProductType(productType!!)) {
                 ProductType.MAGIC_THE_GATHERING -> {
                     val data = getProductDetailsByObjectId<MTGDomainModel>(
                         objectID!!,
-                        getProductType(productType)!!
+                        getProductType(productType,)!!
                     )
                     data?.let {
-                        val prodDisplay = ProductDisplayModel(data)
+                        val prodDisplay = ProductDisplayModel(data,isForSale)
                         productList.add(prodDisplay)
                     }
                 }
@@ -279,7 +281,7 @@
                         getProductType(productType)!!
                     )
                     data?.let {
-                        val prodDisplay= ProductDisplayModel(data)
+                        val prodDisplay= ProductDisplayModel(data,isForSale)
                         productList.add(prodDisplay)
                     }
                 }
@@ -289,7 +291,7 @@
                         getProductType(productType)!!
                     )
                     data?.let {
-                        val prodDisplay= ProductDisplayModel(data)
+                        val prodDisplay= ProductDisplayModel(data,isForSale)
                         productList.add(prodDisplay)
                     }
                 }
@@ -299,7 +301,7 @@
                         getProductType(productType)!!
                     )
                     data?.let {
-                        val prodDisplay = ProductDisplayModel(data)
+                        val prodDisplay = ProductDisplayModel(data,isForSale)
                         productList.add(prodDisplay)
                     }
                 }
@@ -309,7 +311,7 @@
                         getProductType(productType)!!
                     )
                     data?.let {
-                        val prodDisplay = ProductDisplayModel(data)
+                        val prodDisplay = ProductDisplayModel(data,isForSale)
                         productList.add(prodDisplay)
                     }
                 }
Index: app/src/main/java/com/gthr/gthrcollect/data/repository/AskFlowRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gthr.gthrcollect.data.repository\r\n\r\nimport android.net.Uri\r\nimport com.algolia.search.client.ClientSearch\r\nimport com.algolia.search.model.*\r\nimport com.algolia.search.model.indexing.Partial\r\nimport com.google.firebase.database.ktx.database\r\nimport com.google.firebase.ktx.Firebase\r\nimport com.google.firebase.storage.ktx.storage\r\nimport com.gthr.gthrcollect.model.State\r\nimport com.gthr.gthrcollect.model.domain.ShippingInfoDomainModel\r\nimport com.gthr.gthrcollect.model.mapper.*\r\nimport com.gthr.gthrcollect.model.network.firebaserealtimedb.*\r\nimport com.gthr.gthrcollect.utils.constants.AlgoliaConstants\r\nimport com.gthr.gthrcollect.utils.constants.FirebaseRealtimeDatabase\r\nimport com.gthr.gthrcollect.utils.constants.FirebaseStorage\r\nimport com.gthr.gthrcollect.utils.enums.ProductType\r\nimport com.gthr.gthrcollect.utils.logger.GthrLogger\r\nimport io.ktor.util.*\r\nimport kotlinx.coroutines.CoroutineScope\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.async\r\nimport kotlinx.coroutines.flow.catch\r\nimport kotlinx.coroutines.flow.flow\r\nimport kotlinx.coroutines.flow.flowOn\r\nimport kotlinx.coroutines.tasks.await\r\nimport java.io.File\r\n\r\nclass AskFlowRepository {\r\n\r\n    private val mFirebaseRD = Firebase.database.reference\r\n    private val mStorageRef = Firebase.storage.reference\r\n\r\n    fun <T> getProductDetails(id: String, type: ProductType) = flow<State<T>> {\r\n        emit(State.loading())\r\n        var ref = mFirebaseRD\r\n        val networkModelType = when (type) {\r\n            ProductType.MAGIC_THE_GATHERING -> {\r\n                ref = ref.child(FirebaseRealtimeDatabase.MTG_MODEL)\r\n                MTGModel::class.java\r\n            }\r\n            ProductType.YUGIOH -> {\r\n                ref = ref.child(FirebaseRealtimeDatabase.YUGIOH_MODEL)\r\n                YugiohModel::class.java\r\n            }\r\n            ProductType.POKEMON -> {\r\n                ref = ref.child(FirebaseRealtimeDatabase.POKEMON_MODEL)\r\n                PokemonModel::class.java\r\n            }\r\n            ProductType.FUNKO -> {\r\n                ref = ref.child(FirebaseRealtimeDatabase.FUNKO_MODEL)\r\n                FunkoModel::class.java\r\n            }\r\n            ProductType.SEALED_POKEMON, ProductType.SEALED_YUGIOH, ProductType.SEALED_MTG -> {\r\n                ref = ref.child(FirebaseRealtimeDatabase.SEALED_MODEL)\r\n                SealedModel::class.java\r\n            }\r\n        }\r\n        val await = ref.child(id).get().await()\r\n        val productDetailsNetworkModel = await.getValue(networkModelType)\r\n        val productDetailsDomainModel = when (type) {\r\n            ProductType.MAGIC_THE_GATHERING -> (productDetailsNetworkModel as MTGModel).toMTGDomainModel(\r\n                await.key ?: \"\"\r\n            )\r\n            ProductType.YUGIOH -> (productDetailsNetworkModel as YugiohModel).toYugiohDomainModel(\r\n                await.key ?: \"\"\r\n            )\r\n            ProductType.POKEMON -> (productDetailsNetworkModel as PokemonModel).toPokemonDomainModel(\r\n                await.key ?: \"\"\r\n            )\r\n            ProductType.FUNKO -> (productDetailsNetworkModel as FunkoModel).toFunkoDomainModel(\r\n                await.key ?: \"\"\r\n            )\r\n            ProductType.SEALED_POKEMON, ProductType.SEALED_YUGIOH, ProductType.SEALED_MTG -> (productDetailsNetworkModel as SealedModel).toSealedDomainModel(\r\n                await.key ?: \"\"\r\n            )\r\n        }\r\n        emit(State.Success(productDetailsDomainModel as T))\r\n    }.catch {\r\n        // If exception is thrown, emit failed state along with message.\r\n        emit(State.failed(it.message.toString()))\r\n    }.flowOn(Dispatchers.IO)\r\n\r\n    fun getShippingTierInfo(tier: String) = flow<State<ShippingInfoDomainModel>> {\r\n        emit(State.loading())\r\n\r\n        val tierData =\r\n            mFirebaseRD.child(FirebaseRealtimeDatabase.SHIPPING_TIER).child(tier).get().await()\r\n        val data = (tierData.getValue(ShippingInfoModel::class.java)\r\n            ?: ShippingInfoModel()).toDomainModel()\r\n\r\n        emit(State.Success(data))\r\n    }.catch {\r\n        // If exception is thrown, emit failed state along with message.\r\n        emit(State.failed(it.message.toString()))\r\n    }.flowOn(Dispatchers.IO)\r\n\r\n    fun uploadCollectionImage(url: String,imageName : String ,imageSide: String, uid: String) = flow<State<String>> {\r\n        emit(State.loading())\r\n        val file = Uri.fromFile(File(url))\r\n        val ref = mStorageRef.child(FirebaseStorage.COLLECTION_IMAGE).child(uid).child(imageSide).child(\"${imageName}.png\")\r\n        ref.putFile(file).await()\r\n        val url = ref.downloadUrl.await()\r\n        emit(State.success(url.toString()))\r\n    }.catch {\r\n        // If exception is thrown, emit failed state along with message.\r\n        GthrLogger.d(\"sdjns\",\"error   \"+it.message.toString())\r\n        emit(State.failed(it.message.toString()))\r\n    }.flowOn(Dispatchers.IO)\r\n\r\n    fun insertCollection(collectionInfoId : String, mCollectionItemModel : CollectionItemModel) = flow<State<String>>{\r\n        emit(State.loading())\r\n        val push = mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL).child(collectionInfoId).child(FirebaseRealtimeDatabase.COLLECTION_LIST).push()\r\n        mCollectionItemModel.id = push.key!!\r\n        push.setValue(mCollectionItemModel).await()\r\n        emit(State.success(push.key!!))\r\n    }.catch {\r\n        emit(State.failed(it.message.toString()))\r\n    }.flowOn(Dispatchers.IO)\r\n\r\n    fun updateCollection(collectionInfoId : String, collectionKey : String, frontImageUrl : String, backImageUrl : String,askId : String? = null ) = flow<State<Boolean>>{\r\n        emit(State.loading())\r\n        val map = hashMapOf<String,Any>(\r\n            FirebaseRealtimeDatabase.FRONT_IMAGE_URL to frontImageUrl,\r\n            FirebaseRealtimeDatabase.BACK_IMAGE_URL to backImageUrl,\r\n            FirebaseRealtimeDatabase.ASK_REF_KEY to askId!!,\r\n        )\r\n        mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL).child(collectionInfoId)\r\n            .child(FirebaseRealtimeDatabase.COLLECTION_LIST).child(collectionKey)\r\n            .updateChildren(map).await()\r\n        emit(State.success(true))\r\n    }.catch {\r\n        emit(State.failed(it.message.toString()))\r\n    }.flowOn(Dispatchers.IO)\r\n\r\n    fun insertAsk(askItemModel: AskItemModel) = flow<State<String>> {\r\n        emit(State.loading())\r\n        val push = mFirebaseRD.child(FirebaseRealtimeDatabase.ASK_ITEM_MODEL).push()\r\n       // askItemModel.itemRefKey = push.key!!\r\n        GthrLogger.d(\"sdcbsjdb\",\"ASkItemId ${push.key}\")\r\n        push.setValue(askItemModel).await()\r\n        emit(State.success(push.key!!))\r\n    }.catch {\r\n        emit(State.failed(it.message.toString()))\r\n    }.flowOn(Dispatchers.IO)\r\n\r\n    fun updateProductForAsk(lowestAskCost : Int, lowestAskID : String, productType: ProductType, refKey : String, objectID: String) = flow<State<Boolean>> {\r\n        emit(State.loading())\r\n        updateToAlgoliaForAsk(objectID,lowestAskCost,lowestAskID)\r\n        var ref = mFirebaseRD\r\n        ref = when (productType) {\r\n            ProductType.MAGIC_THE_GATHERING -> ref.child(FirebaseRealtimeDatabase.MTG_MODEL)\r\n            ProductType.YUGIOH -> ref.child(FirebaseRealtimeDatabase.YUGIOH_MODEL)\r\n            ProductType.POKEMON -> ref.child(FirebaseRealtimeDatabase.POKEMON_MODEL)\r\n            ProductType.FUNKO -> ref.child(FirebaseRealtimeDatabase.FUNKO_MODEL)\r\n            ProductType.SEALED_POKEMON, ProductType.SEALED_YUGIOH, ProductType.SEALED_MTG -> ref.child(FirebaseRealtimeDatabase.SEALED_MODEL)\r\n        }\r\n        val map = HashMap<String,Any>()\r\n        map[FirebaseRealtimeDatabase.LOWEST_ASK_COST] = lowestAskCost\r\n        map[FirebaseRealtimeDatabase.LOWEST_ASK_ID] = lowestAskID\r\n        ref.child(refKey).updateChildren(map).await()\r\n        emit(State.success(true))\r\n    }.catch {\r\n        emit(State.failed(it.message.toString()))\r\n    }.flowOn(Dispatchers.IO)\r\n\r\n    private suspend fun updateToAlgoliaForAsk(objectID: String, lowestAskCost : Int, lowestAskID : String) {\r\n        val scope = CoroutineScope(Dispatchers.IO).async {\r\n            val client = ClientSearch(\r\n                applicationID = ApplicationID(AlgoliaConstants.APP_ID),\r\n                apiKey = APIKey(AlgoliaConstants.APIKey)\r\n            )\r\n            val indexName = IndexName(AlgoliaConstants.ITEM_NAME)\r\n            val index = client.initIndex(indexName)\r\n\r\n            val ob = listOf(\r\n                ObjectID(objectID) to Partial.Update(Attribute(AlgoliaConstants.LOWEST_ASK_ID), lowestAskID),\r\n                ObjectID(objectID) to Partial.Update(Attribute(AlgoliaConstants.LOWEST_ASK_COST), lowestAskCost),\r\n            )\r\n            index.partialUpdateObjects(ob,true)\r\n        }\r\n        scope.await()\r\n    }\r\n\r\n    fun insertBid(bidItemModel : BidItemModel) = flow<State<String>> {\r\n        emit(State.loading())\r\n        val push = mFirebaseRD.child(FirebaseRealtimeDatabase.BID_ITEM_MODEL).push()\r\n       // bidItemModel.itemRefKey = push.key!!\r\n        GthrLogger.d(\"sdcbsjdb\",\"bidItemId ${push.key}\")\r\n        push.setValue(bidItemModel).await()\r\n        emit(State.success(push.key!!))\r\n    }.catch {\r\n        emit(State.failed(it.message.toString()))\r\n    }.flowOn(Dispatchers.IO)\r\n\r\n\r\n    fun insertBuy(collectionInfoId : String, bidItemId : String) = flow<State<String>>{\r\n        emit(State.loading())\r\n        val push = mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL).child(collectionInfoId).child(FirebaseRealtimeDatabase.BUY_LIST).push()\r\n        push.setValue(bidItemId).await()\r\n        emit(State.success(push.key!!))\r\n    }.catch {\r\n        emit(State.failed(it.message.toString()))\r\n    }.flowOn(Dispatchers.IO)\r\n\r\n    fun updateProductForBid(highestBidCost : Int, highestBidID : String, productType: ProductType, refKey : String, objectID: String) = flow<State<Boolean>> {\r\n        emit(State.loading())\r\n        updateToAlgoliaForBid(objectID,highestBidCost,highestBidID)\r\n        var ref = mFirebaseRD\r\n        ref = when (productType) {\r\n            ProductType.MAGIC_THE_GATHERING -> ref.child(FirebaseRealtimeDatabase.MTG_MODEL)\r\n            ProductType.YUGIOH -> ref.child(FirebaseRealtimeDatabase.YUGIOH_MODEL)\r\n            ProductType.POKEMON -> ref.child(FirebaseRealtimeDatabase.POKEMON_MODEL)\r\n            ProductType.FUNKO -> ref.child(FirebaseRealtimeDatabase.FUNKO_MODEL)\r\n            ProductType.SEALED_POKEMON, ProductType.SEALED_YUGIOH, ProductType.SEALED_MTG -> ref.child(FirebaseRealtimeDatabase.SEALED_MODEL)\r\n        }\r\n        val map = HashMap<String,Any>()\r\n        map[FirebaseRealtimeDatabase.HIGHEST_BID_COST] = highestBidCost\r\n        map[FirebaseRealtimeDatabase.HIGHEST_BID_ID] = highestBidID\r\n        ref.child(refKey).updateChildren(map).await()\r\n        emit(State.success(true))\r\n    }.catch {\r\n        emit(State.failed(it.message.toString()))\r\n    }.flowOn(Dispatchers.IO)\r\n\r\n    private suspend fun updateToAlgoliaForBid(objectID: String, highestBidCost : Int, highestBidID : String) {\r\n        val scope = CoroutineScope(Dispatchers.IO).async {\r\n            val client = ClientSearch(\r\n                applicationID = ApplicationID(AlgoliaConstants.APP_ID),\r\n                apiKey = APIKey(AlgoliaConstants.APIKey)\r\n            )\r\n            val indexName = IndexName(AlgoliaConstants.ITEM_NAME)\r\n            val index = client.initIndex(indexName)\r\n\r\n            val ob = listOf(\r\n                ObjectID(objectID) to Partial.Update(Attribute(AlgoliaConstants.HIGHEST_BID_ID), highestBidID),\r\n                ObjectID(objectID) to Partial.Update(Attribute(AlgoliaConstants.HIGHEST_BID_COST), highestBidCost),\r\n            )\r\n            index.partialUpdateObjects(ob,true)\r\n        }\r\n        scope.await()\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/gthr/gthrcollect/data/repository/AskFlowRepository.kt b/app/src/main/java/com/gthr/gthrcollect/data/repository/AskFlowRepository.kt
--- a/app/src/main/java/com/gthr/gthrcollect/data/repository/AskFlowRepository.kt	(revision 5afe8ae07915a360cc92d45e0a46d20d1c6c84e4)
+++ b/app/src/main/java/com/gthr/gthrcollect/data/repository/AskFlowRepository.kt	(date 1632406327081)
@@ -111,7 +111,6 @@
     fun insertCollection(collectionInfoId : String, mCollectionItemModel : CollectionItemModel) = flow<State<String>>{
         emit(State.loading())
         val push = mFirebaseRD.child(FirebaseRealtimeDatabase.COLLECTION_INFO_MODEL).child(collectionInfoId).child(FirebaseRealtimeDatabase.COLLECTION_LIST).push()
-        mCollectionItemModel.id = push.key!!
         push.setValue(mCollectionItemModel).await()
         emit(State.success(push.key!!))
     }.catch {
@@ -136,7 +135,6 @@
     fun insertAsk(askItemModel: AskItemModel) = flow<State<String>> {
         emit(State.loading())
         val push = mFirebaseRD.child(FirebaseRealtimeDatabase.ASK_ITEM_MODEL).push()
-       // askItemModel.itemRefKey = push.key!!
         GthrLogger.d("sdcbsjdb","ASkItemId ${push.key}")
         push.setValue(askItemModel).await()
         emit(State.success(push.key!!))
@@ -185,7 +183,6 @@
     fun insertBid(bidItemModel : BidItemModel) = flow<State<String>> {
         emit(State.loading())
         val push = mFirebaseRD.child(FirebaseRealtimeDatabase.BID_ITEM_MODEL).push()
-       // bidItemModel.itemRefKey = push.key!!
         GthrLogger.d("sdcbsjdb","bidItemId ${push.key}")
         push.setValue(bidItemModel).await()
         emit(State.success(push.key!!))
Index: app/src/main/java/com/gthr/gthrcollect/ui/profile/my_profile/MyProfileFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gthr.gthrcollect.ui.profile.my_profile\r\n\r\nimport android.app.Activity.RESULT_OK\r\nimport android.content.Intent\r\nimport android.view.View\r\nimport android.widget.TextView\r\nimport androidx.appcompat.widget.AppCompatImageView\r\nimport androidx.constraintlayout.motion.widget.MotionLayout\r\nimport androidx.fragment.app.viewModels\r\nimport androidx.navigation.fragment.navArgs\r\nimport androidx.recyclerview.widget.GridLayoutManager\r\nimport androidx.recyclerview.widget.RecyclerView\r\nimport com.google.firebase.ktx.Firebase\r\nimport com.gthr.gthrcollect.GthrCollect\r\nimport com.gthr.gthrcollect.R\r\nimport com.gthr.gthrcollect.data.repository.DynamicLinkRepository\r\nimport com.gthr.gthrcollect.data.repository.ProfileRepository\r\nimport com.gthr.gthrcollect.databinding.MyProfileBinding\r\nimport com.gthr.gthrcollect.model.State\r\nimport com.gthr.gthrcollect.model.domain.CollectionInfoDomainModel\r\nimport com.gthr.gthrcollect.model.domain.ProductDisplayModel\r\nimport com.gthr.gthrcollect.ui.askflow.AskFlowActivity\r\nimport com.gthr.gthrcollect.ui.base.BaseFragment\r\nimport com.gthr.gthrcollect.ui.editprofile.EditProfileActivity\r\nimport com.gthr.gthrcollect.ui.homebottomnav.HomeBottomNavActivity\r\nimport com.gthr.gthrcollect.ui.homebottomnav.search.SearchFragment\r\nimport com.gthr.gthrcollect.ui.productdetail.ProductDetailActivity\r\nimport com.gthr.gthrcollect.ui.profile.MyProfileViewModelFactory\r\nimport com.gthr.gthrcollect.ui.profile.ProfileActivity\r\nimport com.gthr.gthrcollect.ui.profile.ProfileViewModel\r\nimport com.gthr.gthrcollect.utils.customviews.*\r\nimport com.gthr.gthrcollect.utils.enums.AskFlowType\r\nimport com.gthr.gthrcollect.utils.enums.ProductType\r\nimport com.gthr.gthrcollect.utils.enums.ProfileNavigationType\r\nimport com.gthr.gthrcollect.utils.extensions.*\r\nimport com.gthr.gthrcollect.utils.logger.GthrLogger\r\nimport de.hdodenhof.circleimageview.CircleImageView\r\nimport kotlinx.coroutines.Job\r\nimport kotlinx.coroutines.MainScope\r\nimport kotlinx.coroutines.channels.ticker\r\nimport kotlinx.coroutines.launch\r\n\r\nclass MyProfileFragment : BaseFragment<ProfileViewModel, MyProfileBinding>() {\r\n\r\n\r\n    private val args by navArgs<MyProfileFragmentArgs>()\r\n\r\n    //Variable to indicate whether the user is current user or other user\r\n    private var otherUserId: String? = null\r\n\r\n    override val mViewModel: ProfileViewModel by viewModels {\r\n        MyProfileViewModelFactory(\r\n            ProfileRepository(),\r\n            DynamicLinkRepository(),\r\n            otherUserId\r\n        )\r\n    }\r\n\r\n    override fun getViewBinding() = MyProfileBinding.inflate(layoutInflater)\r\n\r\n    private var mainJob: Job? = null\r\n\r\n    private lateinit var mAdapter: CollectionsAdapter\r\n    private lateinit var mMlMain: MotionLayout\r\n    private lateinit var mRvMain: RecyclerView\r\n    private lateinit var mFollowers: CustomFelloView\r\n    private lateinit var mFollowing: CustomFelloView\r\n    private lateinit var mSold: CustomFelloView\r\n    private lateinit var mFavourites: CustomCollectionButton\r\n    private lateinit var mEdit: AppCompatImageView\r\n    private lateinit var mIvShare: AppCompatImageView\r\n    private lateinit var mBtnFollow: CustomFollowView\r\n    private lateinit var mAbout: TextView\r\n    private lateinit var mDisplayName: TextView\r\n    private lateinit var mProfilePic: CircleImageView\r\n\r\n    private lateinit var mAll: CustomCollectionTypeView\r\n    private lateinit var mCards: CustomCollectionTypeView\r\n    private lateinit var mToys: CustomCollectionTypeView\r\n    private lateinit var mBuyList: CustomCollectionTypeView\r\n    private lateinit var mCcbCollection: CustomCollectionButton\r\n\r\n    private lateinit var mSearchBar : CustomSearchView\r\n\r\n    var mSearchTypingJob: Job? = null\r\n    private var imageURl: String = \"\"\r\n\r\n    //List of Collection filter views\r\n    private lateinit var mCctvList: List<CustomCollectionTypeView>\r\n\r\n    override fun onBinding() {\r\n        try {\r\n            otherUserId = args.otherUserId/*\"-MSsuhfKKQP7mxZocWER\"*/\r\n        } catch (e: Exception) {\r\n            GthrLogger.e(message = e.message.toString())\r\n        }\r\n\r\n        initViews()\r\n        setUpClickListeners()\r\n        //   setUpRecyclerView()\r\n        setUpObservers()\r\n\r\n        mSearchBar.setTextChangeListener {\r\n            mSearchTypingJob?.cancel()\r\n            mSearchTypingJob = MainScope().launch {\r\n                ticker(SEARCH_DELAY).receive()  //Add some delay before an api call\r\n                searchProduct()\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun searchProduct() {\r\n        val productList = mutableListOf<ProductDisplayModel>()\r\n        when{\r\n            mAll.mIsActive -> {\r\n                for (productDisplayModel in mViewModel.mAllCollectionProductList) {\r\n                    if(productDisplayModel?.name?.contains(mSearchBar.text.toString(),true)!!)\r\n                        productList.add(productDisplayModel)\r\n                    else if(productDisplayModel?.productNumber?.contains(mSearchBar.text.toString(),true)!!)\r\n                        productList.add(productDisplayModel)\r\n                    else if(productDisplayModel?.rarity?.contains(mSearchBar.text.toString(),true)!!)\r\n                        productList.add(productDisplayModel)\r\n                }\r\n            }\r\n            mCards.mIsActive -> {\r\n                for (productDisplayModel in mViewModel.mAllCollectionProductList) {\r\n                    if(productDisplayModel.productType==ProductType.POKEMON||\r\n                        productDisplayModel.productType==ProductType.MAGIC_THE_GATHERING||\r\n                        productDisplayModel.productType==ProductType.YUGIOH){\r\n                        if(productDisplayModel?.name?.contains(mSearchBar.text.toString(),true)!!)\r\n                            productList.add(productDisplayModel)\r\n                        else if(productDisplayModel?.productNumber?.contains(mSearchBar.text.toString(),true)!!)\r\n                            productList.add(productDisplayModel)\r\n                        else if(productDisplayModel?.rarity?.contains(mSearchBar.text.toString(),true)!!)\r\n                            productList.add(productDisplayModel)\r\n                    }\r\n                }\r\n            }\r\n            mToys.mIsActive -> {\r\n                for (productDisplayModel in mViewModel.mAllCollectionProductList) {\r\n                    if(productDisplayModel.productType==ProductType.FUNKO){\r\n                        if(productDisplayModel?.name?.contains(mSearchBar.text.toString(),true)!!)\r\n                            productList.add(productDisplayModel)\r\n                        else if(productDisplayModel?.productNumber?.contains(mSearchBar.text.toString(),true)!!)\r\n                            productList.add(productDisplayModel)\r\n                        else if(productDisplayModel?.rarity?.contains(mSearchBar.text.toString(),true)!!)\r\n                            productList.add(productDisplayModel)\r\n                    }\r\n                }\r\n            }\r\n            mBuyList.mIsActive -> {\r\n                for(productDisplayModel in mViewModel.mAllBidProductList) {\r\n                    if(productDisplayModel?.name?.contains(mSearchBar.text.toString(),true)!!)\r\n                        productList.add(productDisplayModel)\r\n                    else if(productDisplayModel?.productNumber?.contains(mSearchBar.text.toString(),true)!!)\r\n                        productList.add(productDisplayModel)\r\n                    else if(productDisplayModel?.rarity?.contains(mSearchBar.text.toString(),true)!!)\r\n                        productList.add(productDisplayModel)\r\n                }\r\n            }\r\n        }\r\n        mViewModel.setDisplayCollectionProducts(productList)\r\n    }\r\n\r\n\r\n    private fun initViews() {\r\n        mViewBinding.run {\r\n            mMlMain = mlMain\r\n            mRvMain = rvMain\r\n            mFavourites = ccbFavourites\r\n            mFollowers = profileLayout.follower\r\n            mFollowing = profileLayout.following\r\n            mSold = profileLayout.sold\r\n            mEdit = profileLayout.ivEdit\r\n            mIvShare = profileLayout.ivShare\r\n            mBtnFollow = profileLayout.ivFollow\r\n            mAll = cctvAll\r\n            mCards = cctvCards\r\n            mToys = cctvToys\r\n            mBuyList = cctvBuyList\r\n            mCctvList = listOf(mAll, mCards, mToys, mBuyList)\r\n            mAbout = profileLayout.tvUserBio\r\n            mProfilePic = profileLayout.ivProfilePic\r\n            mDisplayName = profileLayout.tvUserName\r\n            mCcbCollection = ccbCollection\r\n            mSearchBar = csvSearch\r\n            initProgressBar(layoutProgress)\r\n            setViewsForOtherUser()\r\n            setUpRecyclerView()\r\n        }\r\n    }\r\n\r\n    private fun setViewsForOtherUser() {\r\n        if (isOtherUser()) {\r\n            mEdit.gone()\r\n            mBtnFollow.visible()\r\n            mFollowing.setTypeCollection()\r\n            mMlMain.getConstraintSet(R.id.start)?.let { startConstraintSet ->\r\n                startConstraintSet.setVisibility(R.id.linearLayoutCompat, View.GONE)\r\n                startConstraintSet.setVisibility(R.id.collection_layout, View.GONE)\r\n            }\r\n\r\n        }\r\n\r\n        mAdapter = CollectionsAdapter(CustomProductCell.State.FOR_SALE) {\r\n            startActivity(ProductDetailActivity.getInstance(requireContext(), it.objectID!!,it.productType!!))\r\n        }\r\n    }\r\n\r\n    private fun setUpObservers() {\r\n        mViewModel.mProductDynamicLink.observe(viewLifecycleOwner) { it ->\r\n            it.contentIfNotHandled?.let {\r\n                when (it) {\r\n                    is State.Loading -> showProgressBar()\r\n                    is State.Success -> {\r\n                        showProgressBar(false)\r\n                        val intent = Intent()\r\n                        // val msg = \"Click and install this application $shortLink Refer code : mayankbaba\"\r\n                        intent.action = Intent.ACTION_SEND\r\n                        intent.putExtra(Intent.EXTRA_TEXT, it.data)\r\n                        intent.type = \"text/plain\"\r\n                        startActivity(intent)\r\n                    }\r\n                    is State.Failed -> {\r\n                        showProgressBar(false)\r\n                        showToast(it.message)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        mViewModel.userCollectionInfo.observe(viewLifecycleOwner) { it ->\r\n            it.contentIfNotHandled?.let {\r\n                when (it) {\r\n                    is State.Loading -> showProgressBar()\r\n                    is State.Success -> {\r\n                        showProgressBar(false)\r\n                        setData(it.data)\r\n                        if(it.data.collectionList!=null&&it.data.collectionList.size>0)\r\n                            mViewModel.getCollectionProduct(it.data.collectionList)\r\n                    }\r\n                    is State.Failed -> {\r\n                        showProgressBar(false)\r\n                        showToast(it.message)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        mViewModel.mAllCollectionProduct.observe(viewLifecycleOwner) { it ->\r\n            it.contentIfNotHandled?.let {\r\n                when (it) {\r\n                    is State.Loading -> showProgressBar()\r\n                    is State.Success -> {\r\n                        showProgressBar(false)\r\n                        GthrLogger.i(\"sdkcnsdknc\",\"product :  ${it.data}\")\r\n                        GthrLogger.i(\"sdkcnsdknc\",\"product size :  ${it.data.size}\")\r\n                        if(it.data!=null&& it.data.isNotEmpty()){\r\n                            mViewModel.setAllCollectionProductList(it.data)\r\n                            mViewModel.setDisplayCollectionProducts(it.data)\r\n                        }\r\n                        mViewModel.fetchBidProducts(GthrCollect.prefs?.getUserCollectionId()!!)\r\n                    }\r\n                    is State.Failed -> {\r\n                        showProgressBar(false)\r\n                        showToast(it.message)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        mViewModel.mAllBidProduct.observe(viewLifecycleOwner) { it ->\r\n            it.contentIfNotHandled?.let {\r\n                when (it) {\r\n                    is State.Loading -> showProgressBar()\r\n                    is State.Success -> {\r\n                        showProgressBar(false)\r\n                        GthrLogger.i(\"sdkcnsdknc\",\"product :  ${it.data}\")\r\n                        GthrLogger.i(\"sdkcnsdknc\",\"product size :  ${it.data.size}\")\r\n                        if(it.data!=null&& it.data.isNotEmpty()){\r\n                            mViewModel.setAllBidProduct(it.data)\r\n                        }\r\n                    }\r\n                    is State.Failed -> {\r\n                        showProgressBar(false)\r\n                        showToast(it.message)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        mViewModel.mDisplayCollectionProduct.observe(viewLifecycleOwner) { it ->\r\n            it.contentIfNotHandled?.let {\r\n                GthrLogger.i(\"sdkcnsdknc\",\"List $it\")\r\n                GthrLogger.i(\"sdkcnsdknc\",\"List ${it.size}\")\r\n                mAdapter.submitList(it.map { it.copy() })\r\n            }\r\n        }\r\n\r\n\r\n\r\n        mViewModel.followUser.observe(viewLifecycleOwner, {\r\n            it.contentIfNotHandled?.let {\r\n                when (it) {\r\n                    is State.Loading -> {\r\n                        showProgressBar()\r\n                    }\r\n                    is State.Success -> {\r\n                        showProgressBar(false)\r\n                        showToast(it.data)\r\n                        mBtnFollow.setFollowing()\r\n                    }\r\n                    is State.Failed -> {\r\n                        showProgressBar(false)\r\n                        showToast(it.message)\r\n                    }\r\n                }\r\n            }\r\n        })\r\n\r\n        mViewModel.unFollowUser.observe(viewLifecycleOwner, {\r\n            it.contentIfNotHandled?.let {\r\n                when (it) {\r\n                    is State.Loading -> {\r\n                        showProgressBar()\r\n                    }\r\n                    is State.Success -> {\r\n                        showProgressBar(false)\r\n                        showToast(it.data)\r\n                        mBtnFollow.setFollow()\r\n                    }\r\n                    is State.Failed -> {\r\n                        showProgressBar(false)\r\n                        showToast(it.message)\r\n                    }\r\n                }\r\n            }\r\n        })\r\n\r\n    }\r\n\r\n    private fun setUpClickListeners() {\r\n        mIvShare.setOnClickListener {\r\n            mViewModel.getProductDynamicLink(otherUserId ?: GthrCollect.prefs?.getUserCollectionId().toString())\r\n        }\r\n\r\n        mFollowers.setOnClickListener {\r\n            goToProfilePage(ProfileNavigationType.FOLLOWERS, otherUserId)\r\n        }\r\n        mFollowing.setOnClickListener {\r\n            if (!isOtherUser())\r\n                goToProfilePage(ProfileNavigationType.FOLLOWING)\r\n        }\r\n        mSold.setOnClickListener {\r\n            goToProfilePage(ProfileNavigationType.SOLD)\r\n        }\r\n        mFavourites.setOnClickListener {\r\n            goToProfilePage(ProfileNavigationType.FAVOURITES)\r\n        }\r\n        mEdit.setOnClickListener {\r\n            startActivityForResult(\r\n                EditProfileActivity.getInstance(\r\n                    requireContext(),\r\n                    display_name = mDisplayName.text.toString().trim(),\r\n                    about = mAbout.text.toString().trim(), imageURl\r\n                ),\r\n                REQUEST_CODE_EDIT_PROFILE\r\n            )\r\n        }\r\n\r\n        mBtnFollow.setOnClickListener {\r\n            if(GthrCollect.prefs?.isUserLoggedIn()==true){\r\n                if (mBtnFollow.mCurrentType == CustomFollowView.Type.FOLLOW) {\r\n                    mViewModel.followToUser(otherUserId!!)\r\n                } else {\r\n                    mViewModel.unFollowToUser(otherUserId!!)\r\n                }\r\n            }\r\n            else{\r\n                startActivity(HomeBottomNavActivity.getInstance(requireContext()).apply {\r\n                    flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK\r\n                })\r\n                activity?.finish()\r\n            }\r\n\r\n        }\r\n\r\n        mCctvList.forEach { view ->\r\n            view.setOnClickListener {\r\n                view.selectView()\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun setData(data: CollectionInfoDomainModel) {\r\n        mAbout.text = data.about\r\n        mDisplayName.text = data.collectionDisplayName\r\n        mFollowers.setCount(data.followersList?.size.toString())\r\n        mFollowing.setCount(\r\n            if (isOtherUser())\r\n                data.collectionList?.size?.toString() ?: \"0\"\r\n            else\r\n                data.favoriteCollectionList?.size.toString()\r\n        )\r\n        imageURl = data.profileImage\r\n        mProfilePic.setProfileImage(imageURl)\r\n\r\n        if (isOtherUser()) {\r\n            for (item: String in data.followersList!!) {\r\n                if (item == GthrCollect.prefs?.userInfoModel?.collectionId.toString()) {\r\n                    mBtnFollow.setFollowing()\r\n                    break\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    private fun setUpRecyclerView() {\r\n        mRvMain.apply {\r\n            layoutManager = GridLayoutManager(requireContext(), 2)\r\n            mRvMain.adapter = mAdapter\r\n        }\r\n    }\r\n\r\n    private fun goToProfilePage(type: ProfileNavigationType, userId: String? = null) {\r\n        startActivity(ProfileActivity.getInstance(requireContext(), type, userId))\r\n    }\r\n\r\n    //Method to select Single Collection Filter\r\n    private fun CustomCollectionTypeView.selectView() {\r\n        if (this.mIsActive) return\r\n\r\n        mainJob?.cancel()\r\n        mainJob = MainScope().launch {\r\n            mCctvList.forEach {\r\n                it.setActive(it == this@selectView)\r\n            }\r\n            when {\r\n                mAll.mIsActive || mCards.mIsActive || mToys.mIsActive -> {\r\n                    mAdapter = CollectionsAdapter(CustomProductCell.State.FOR_SALE) {\r\n                        startActivity(ProductDetailActivity.getInstance(requireContext(), it.objectID!!,it.productType!!))\r\n                    }\r\n                    mRvMain.adapter = mAdapter\r\n                }\r\n                mBuyList.mIsActive -> {\r\n                    mAdapter = CollectionsAdapter(CustomProductCell.State.WANT) {\r\n                        startActivity(ProductDetailActivity.getInstance(requireContext(), it.objectID!!,it.productType!!))\r\n                    }\r\n                    mRvMain.adapter = mAdapter\r\n                }\r\n            }\r\n            mSearchTypingJob?.cancel()\r\n            mSearchTypingJob = MainScope().launch {\r\n                ticker(SEARCH_DELAY).receive()  //Add some delay before an api call\r\n                searchProduct()\r\n            }\r\n        }\r\n    }\r\n\r\n    //Method to check if current user is Other User i.e. viewing other's profile\r\n    private fun isOtherUser() = !otherUserId.isNullOrEmpty()\r\n\r\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\r\n        super.onActivityResult(requestCode, resultCode, data)\r\n        data?.let {\r\n            when (requestCode) {\r\n                REQUEST_CODE_EDIT_PROFILE -> {\r\n                    if (resultCode == RESULT_OK)\r\n                        mViewModel.fetchUserProfileData(\r\n                            GthrCollect.prefs?.getUserCollectionId().toString()\r\n                        )\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        mainJob?.cancel()\r\n    }\r\n\r\n    companion object {\r\n        private const val REQUEST_CODE_EDIT_PROFILE = 69\r\n        private const val SEARCH_DELAY = 1000L\r\n    }\r\n\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/gthr/gthrcollect/ui/profile/my_profile/MyProfileFragment.kt b/app/src/main/java/com/gthr/gthrcollect/ui/profile/my_profile/MyProfileFragment.kt
--- a/app/src/main/java/com/gthr/gthrcollect/ui/profile/my_profile/MyProfileFragment.kt	(revision 5afe8ae07915a360cc92d45e0a46d20d1c6c84e4)
+++ b/app/src/main/java/com/gthr/gthrcollect/ui/profile/my_profile/MyProfileFragment.kt	(date 1632406327089)
@@ -114,12 +114,11 @@
         when{
             mAll.mIsActive -> {
                 for (productDisplayModel in mViewModel.mAllCollectionProductList) {
-                    if(productDisplayModel?.name?.contains(mSearchBar.text.toString(),true)!!)
-                        productList.add(productDisplayModel)
-                    else if(productDisplayModel?.productNumber?.contains(mSearchBar.text.toString(),true)!!)
-                        productList.add(productDisplayModel)
-                    else if(productDisplayModel?.rarity?.contains(mSearchBar.text.toString(),true)!!)
-                        productList.add(productDisplayModel)
+                    if (productDisplayModel?.name?.contains(mSearchBar.text.toString(),true)!!||
+                        productDisplayModel?.productNumber?.contains(mSearchBar.text.toString(),true)!!||
+                        productDisplayModel?.rarity?.contains(mSearchBar.text.toString(),true)!!||
+                        productDisplayModel?.description?.contains(mSearchBar.text.toString(),true)!!)
+                            productList.add(productDisplayModel)
                 }
             }
             mCards.mIsActive -> {
@@ -127,11 +126,10 @@
                     if(productDisplayModel.productType==ProductType.POKEMON||
                         productDisplayModel.productType==ProductType.MAGIC_THE_GATHERING||
                         productDisplayModel.productType==ProductType.YUGIOH){
-                        if(productDisplayModel?.name?.contains(mSearchBar.text.toString(),true)!!)
-                            productList.add(productDisplayModel)
-                        else if(productDisplayModel?.productNumber?.contains(mSearchBar.text.toString(),true)!!)
-                            productList.add(productDisplayModel)
-                        else if(productDisplayModel?.rarity?.contains(mSearchBar.text.toString(),true)!!)
+                        if (productDisplayModel?.name?.contains(mSearchBar.text.toString(),true)!!||
+                            productDisplayModel?.productNumber?.contains(mSearchBar.text.toString(),true)!!||
+                            productDisplayModel?.rarity?.contains(mSearchBar.text.toString(),true)!!||
+                            productDisplayModel?.description?.contains(mSearchBar.text.toString(),true)!!)
                             productList.add(productDisplayModel)
                     }
                 }
@@ -139,22 +137,20 @@
             mToys.mIsActive -> {
                 for (productDisplayModel in mViewModel.mAllCollectionProductList) {
                     if(productDisplayModel.productType==ProductType.FUNKO){
-                        if(productDisplayModel?.name?.contains(mSearchBar.text.toString(),true)!!)
-                            productList.add(productDisplayModel)
-                        else if(productDisplayModel?.productNumber?.contains(mSearchBar.text.toString(),true)!!)
-                            productList.add(productDisplayModel)
-                        else if(productDisplayModel?.rarity?.contains(mSearchBar.text.toString(),true)!!)
+                        if (productDisplayModel?.name?.contains(mSearchBar.text.toString(),true)!!||
+                            productDisplayModel?.productNumber?.contains(mSearchBar.text.toString(),true)!!||
+                            productDisplayModel?.rarity?.contains(mSearchBar.text.toString(),true)!!||
+                            productDisplayModel?.description?.contains(mSearchBar.text.toString(),true)!!)
                             productList.add(productDisplayModel)
                     }
                 }
             }
             mBuyList.mIsActive -> {
                 for(productDisplayModel in mViewModel.mAllBidProductList) {
-                    if(productDisplayModel?.name?.contains(mSearchBar.text.toString(),true)!!)
-                        productList.add(productDisplayModel)
-                    else if(productDisplayModel?.productNumber?.contains(mSearchBar.text.toString(),true)!!)
-                        productList.add(productDisplayModel)
-                    else if(productDisplayModel?.rarity?.contains(mSearchBar.text.toString(),true)!!)
+                    if (productDisplayModel?.name?.contains(mSearchBar.text.toString(),true)!!||
+                        productDisplayModel?.productNumber?.contains(mSearchBar.text.toString(),true)!!||
+                        productDisplayModel?.rarity?.contains(mSearchBar.text.toString(),true)!!||
+                        productDisplayModel?.description?.contains(mSearchBar.text.toString(),true)!!)
                         productList.add(productDisplayModel)
                 }
             }
@@ -257,7 +253,7 @@
                             mViewModel.setAllCollectionProductList(it.data)
                             mViewModel.setDisplayCollectionProducts(it.data)
                         }
-                        mViewModel.fetchBidProducts(GthrCollect.prefs?.getUserCollectionId()!!)
+                        mViewModel.fetchBidProducts(otherUserId ?: GthrCollect.prefs?.getUserCollectionId().toString())
                     }
                     is State.Failed -> {
                         showProgressBar(false)
@@ -288,7 +284,7 @@
 
         mViewModel.mDisplayCollectionProduct.observe(viewLifecycleOwner) { it ->
             it.contentIfNotHandled?.let {
-                GthrLogger.i("sdkcnsdknc","List $it")
+                GthrLogger.i("djscndsc","List $it")
                 GthrLogger.i("sdkcnsdknc","List ${it.size}")
                 mAdapter.submitList(it.map { it.copy() })
             }
Index: app/src/main/java/com/gthr/gthrcollect/ui/profile/my_profile/CollectionsAdapter.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gthr.gthrcollect.ui.profile.my_profile\r\n\r\nimport android.view.LayoutInflater\r\nimport android.view.ViewGroup\r\nimport androidx.recyclerview.widget.DiffUtil\r\nimport androidx.recyclerview.widget.ListAdapter\r\nimport androidx.recyclerview.widget.RecyclerView\r\nimport com.gthr.gthrcollect.databinding.ItemTestProductBinding\r\nimport com.gthr.gthrcollect.model.domain.ProductDisplayModel\r\nimport com.gthr.gthrcollect.utils.customviews.CustomProductCell\r\nimport com.gthr.gthrcollect.utils.enums.ProductType\r\n\r\nclass CollectionsAdapter(val state: CustomProductCell.State, val callback: (ProductDisplayModel) -> Unit) : ListAdapter<ProductDisplayModel, CollectionsAdapter.ProductViewHolder>(DiffCallback) {\r\n\r\n    companion object DiffCallback : DiffUtil.ItemCallback<ProductDisplayModel>() {\r\n        override fun areItemsTheSame(oldItem: ProductDisplayModel, newItem: ProductDisplayModel): Boolean {\r\n            return oldItem.refKey == newItem.refKey\r\n        }\r\n\r\n        override fun areContentsTheSame(oldItem: ProductDisplayModel, newItem: ProductDisplayModel): Boolean {\r\n            return oldItem == newItem\r\n        }\r\n    }\r\n\r\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ProductViewHolder =\r\n        ProductViewHolder(\r\n            ItemTestProductBinding.inflate(\r\n                LayoutInflater.from(parent.context), parent, false\r\n            )\r\n        )\r\n\r\n    override fun onBindViewHolder(holder: ProductViewHolder, position: Int) {\r\n        holder.bind()\r\n        holder.binding.item.setState(state)\r\n    }\r\n\r\n    inner class ProductViewHolder(var binding: ItemTestProductBinding) :\r\n        RecyclerView.ViewHolder(binding.root) {\r\n        fun bind() {\r\n            when (getItem(layoutPosition).productType) {\r\n                ProductType.FUNKO -> binding.item.setType(CustomProductCell.Type.FUNKO)\r\n                ProductType.POKEMON -> binding.item.setType(CustomProductCell.Type.CARDS)\r\n                ProductType.MAGIC_THE_GATHERING -> binding.item.setType(CustomProductCell.Type.FUNKO)\r\n                ProductType.YUGIOH -> binding.item.setType(CustomProductCell.Type.CARDS)\r\n                ProductType.SEALED_POKEMON, ProductType.SEALED_MTG, ProductType.SEALED_YUGIOH -> binding.item.setType(\r\n                    CustomProductCell.Type.SEALED\r\n                )\r\n            }\r\n            binding.item.setValue(getItem(layoutPosition))\r\n            binding.root.setOnClickListener {\r\n                callback(getItem(layoutPosition))\r\n            }\r\n        }\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/gthr/gthrcollect/ui/profile/my_profile/CollectionsAdapter.kt b/app/src/main/java/com/gthr/gthrcollect/ui/profile/my_profile/CollectionsAdapter.kt
--- a/app/src/main/java/com/gthr/gthrcollect/ui/profile/my_profile/CollectionsAdapter.kt	(revision 5afe8ae07915a360cc92d45e0a46d20d1c6c84e4)
+++ b/app/src/main/java/com/gthr/gthrcollect/ui/profile/my_profile/CollectionsAdapter.kt	(date 1632406327089)
@@ -31,13 +31,13 @@
 
     override fun onBindViewHolder(holder: ProductViewHolder, position: Int) {
         holder.bind()
-        holder.binding.item.setState(state)
     }
 
     inner class ProductViewHolder(var binding: ItemTestProductBinding) :
         RecyclerView.ViewHolder(binding.root) {
         fun bind() {
-            when (getItem(layoutPosition).productType) {
+            val item = getItem(layoutPosition)
+            when (item.productType) {
                 ProductType.FUNKO -> binding.item.setType(CustomProductCell.Type.FUNKO)
                 ProductType.POKEMON -> binding.item.setType(CustomProductCell.Type.CARDS)
                 ProductType.MAGIC_THE_GATHERING -> binding.item.setType(CustomProductCell.Type.FUNKO)
@@ -46,9 +46,20 @@
                     CustomProductCell.Type.SEALED
                 )
             }
-            binding.item.setValue(getItem(layoutPosition))
+
+            if(state==CustomProductCell.State.FOR_SALE){
+                if(item.isForSale!=null&&item.isForSale)
+                    binding.item.setState(state)
+                else
+                    binding.item.setState(CustomProductCell.State.NORMAL)
+            }
+            else{
+                binding.item.setState(state)
+            }
+
+            binding.item.setValue(item)
             binding.root.setOnClickListener {
-                callback(getItem(layoutPosition))
+                callback(item)
             }
         }
     }
Index: app/src/main/java/com/gthr/gthrcollect/ui/askflow/AskFlowViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gthr.gthrcollect.ui.askflow\r\n\r\nimport androidx.lifecycle.LiveData\r\nimport androidx.lifecycle.MutableLiveData\r\nimport androidx.lifecycle.viewModelScope\r\nimport com.gthr.gthrcollect.GthrCollect\r\nimport com.gthr.gthrcollect.data.repository.AskFlowRepository\r\nimport com.gthr.gthrcollect.model.Event\r\nimport com.gthr.gthrcollect.model.State\r\nimport com.gthr.gthrcollect.model.domain.*\r\nimport com.gthr.gthrcollect.model.mapper.toRealtimeDatabaseModel\r\nimport com.gthr.gthrcollect.ui.base.BaseViewModel\r\nimport com.gthr.gthrcollect.utils.constants.FirebaseStorage\r\nimport com.gthr.gthrcollect.utils.enums.ConditionType\r\nimport com.gthr.gthrcollect.utils.enums.EditionType\r\nimport com.gthr.gthrcollect.utils.enums.ProductCategory\r\nimport com.gthr.gthrcollect.utils.enums.ProductType\r\nimport com.gthr.gthrcollect.utils.extensions.getUserCollectionId\r\nimport com.gthr.gthrcollect.utils.extensions.isValidPrice\r\nimport com.gthr.gthrcollect.utils.extensions.toTwoDecimal\r\nimport com.gthr.gthrcollect.utils.getProductCategory\r\nimport com.gthr.gthrcollect.utils.helper.*\r\nimport com.gthr.gthrcollect.utils.logger.GthrLogger\r\nimport kotlinx.coroutines.Job\r\nimport kotlinx.coroutines.flow.collect\r\nimport kotlinx.coroutines.launch\r\n\r\nclass AskFlowViewModel(private val repository: AskFlowRepository) : BaseViewModel() {\r\n\r\n    var shippingTierJob: Job? = null\r\n\r\n    var productType: ProductType? = null\r\n        private set\r\n\r\n    var productDisplayModel: ProductDisplayModel? = null\r\n        private set\r\n\r\n    private val _isSell = MutableLiveData<Boolean>()\r\n    val isSell: LiveData<Boolean>\r\n        get() = _isSell\r\n\r\n    private val _askPrice = MutableLiveData<Double>()\r\n    val askPrice: LiveData<Double>\r\n        get() = _askPrice\r\n\r\n    private val _buyListPrice = MutableLiveData<Double>()\r\n    val buyListPrice: LiveData<Double>\r\n        get() = _buyListPrice\r\n\r\n    private val _shippingTierInfo = MutableLiveData<Event<State<ShippingInfoDomainModel>>>()\r\n    val shippingTierInfo: LiveData<Event<State<ShippingInfoDomainModel>>>\r\n        get() = _shippingTierInfo\r\n\r\n    val totalPayoutRate: Double\r\n        get() = addRates(\r\n            //Price\r\n            askPrice.value?.toDouble(),\r\n            //Shipping Price\r\n            +shippingProcessing,\r\n            -sellingFee,\r\n            -paymentProcessing\r\n        )\r\n\r\n    val shippingProcessing: Double\r\n        get() = if (shippingTierInfo.value?.peekContent() == null)\r\n            0.00\r\n        else\r\n            ((shippingTierInfo.value?.peekContent() as State.Success).data.frontEndShippingProcessing.toDoubleOrNull()\r\n                ?: 0.00)\r\n\r\n    val sellingFee: Double\r\n        get() = (((askPrice.value?.toDouble()\r\n            ?: 0.00) * PERCENT_SELLING_FEE) / 100.00).toTwoDecimal()\r\n\r\n    val paymentProcessing: Double\r\n        get() = (((askPrice.value?.toDouble()\r\n            ?: 0.00) * PERCENT_PAYMENT_PROCESSING) / 100.00).toTwoDecimal()\r\n\r\n    private fun addRates(vararg rate: Double?): Double {\r\n        var total = 0.00\r\n        rate.forEach {\r\n            if (it != null)\r\n                total += it\r\n        }\r\n        return total.toTwoDecimal()\r\n    }\r\n\r\n\r\n\r\n    /* Selected Language, Edition, Condition Title & Value */\r\n    private val _selectedLanguage = MutableLiveData<Event<LanguageDomainModel>>()\r\n    val selectedLanguage: LiveData<Event<LanguageDomainModel>>\r\n        get() = _selectedLanguage\r\n\r\n    private val _selectedEdition = MutableLiveData<Event<EditionType>>()\r\n    val selectedEdition: LiveData<Event<EditionType>>\r\n        get() = _selectedEdition\r\n\r\n    private val _selectedConditionTitle = MutableLiveData<Event<ConditionType>>()\r\n    val selectedConditionTitle: LiveData<Event<ConditionType>>\r\n        get() = _selectedConditionTitle\r\n\r\n    private val _selectedCondition = MutableLiveData<Event<ConditionDomainModel>>()\r\n    val selectedCondition: LiveData<Event<ConditionDomainModel>>\r\n        get() = _selectedCondition\r\n\r\n    /* Front & Back Image */\r\n    private val _frontImageUrl = MutableLiveData<String>()\r\n    val frontImageUrl: LiveData<String>\r\n        get() = _frontImageUrl\r\n\r\n    private val _backImageUrl = MutableLiveData<String>()\r\n    val backImageUrl: LiveData<String>\r\n        get() = _backImageUrl\r\n\r\n\r\n    /** Language, Edition & Condition Lists for [ProductCategory.CARDS] */\r\n    private val _languageList = MutableLiveData<Event<List<LanguageDomainModel>>>()\r\n    val languageList: LiveData<Event<List<LanguageDomainModel>>>\r\n        get() = _languageList\r\n\r\n    private val _editionList = MutableLiveData<Event<List<EditionType>>>()\r\n    val editionList: LiveData<Event<List<EditionType>>>\r\n        get() = _editionList\r\n\r\n    private val _conditionList = MutableLiveData<Event<List<ConditionDomainModel>>>()\r\n    val conditionList: LiveData<Event<List<ConditionDomainModel>>>\r\n        get() = _conditionList\r\n\r\n    init {\r\n        setSelectedConditionTitle(ConditionType.UG)  //Default selection UG i.e. Raw\r\n        val addressList = GthrCollect.prefs?.userInfoModel?.addressList\r\n        addressList?.let {\r\n            for(address in addressList){\r\n                if(address.isSelected){\r\n                    mAddress = address\r\n                    break\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fun setProductType(productType: ProductType) {\r\n        this.productType = productType\r\n    }\r\n\r\n    fun setProductDisplayModel(productDisplayModel: ProductDisplayModel) {\r\n        this.productDisplayModel = productDisplayModel\r\n    }\r\n\r\n    fun setSell(isSell: Boolean) {\r\n        _isSell.value = isSell\r\n    }\r\n\r\n    fun setFrontImage(bitmapUrl: String) {\r\n        _frontImageUrl.value = bitmapUrl\r\n    }\r\n\r\n    fun setBackImage(bitmapUrl: String) {\r\n        _backImageUrl.value = bitmapUrl\r\n    }\r\n\r\n    fun setAskPrice(price: Double) {\r\n        _askPrice.value = price.toString().isValidPrice().toDoubleOrNull() ?: 0.00\r\n    }\r\n\r\n    fun setBuylistPrice(price: Double) {\r\n        _buyListPrice.value = price.toString().isValidPrice().toDoubleOrNull() ?: 0.00\r\n    }\r\n\r\n    fun setSelectedLanguage(languageDomainModel: LanguageDomainModel) {\r\n        _selectedLanguage.value = Event(languageDomainModel)\r\n        retrieveEditionList(productType!!)\r\n    }\r\n\r\n    fun setSelectedEdition(editionType: EditionType) {\r\n        _selectedEdition.value = Event(editionType)\r\n        retrieveConditionList(ConditionType.UG)\r\n    }\r\n\r\n    fun setSelectedConditionTitle(conditionType: ConditionType) {\r\n        _selectedConditionTitle.value = Event(conditionType)\r\n        retrieveConditionList(conditionType)\r\n    }\r\n\r\n    fun setSelectedConditionValue(conditionDomainModel: ConditionDomainModel) {\r\n        _selectedCondition.value = Event(conditionDomainModel)\r\n    }\r\n\r\n    /* Product Types */\r\n    private val _mtgProductDetails = MutableLiveData<Event<State<MTGDomainModel>>>()\r\n    val mtgProductDetails: LiveData<Event<State<MTGDomainModel>>>\r\n        get() = _mtgProductDetails\r\n\r\n    private val _pokemonProductDetails = MutableLiveData<Event<State<PokemonDomainModel>>>()\r\n    val pokemonProductDetails: LiveData<Event<State<PokemonDomainModel>>>\r\n        get() = _pokemonProductDetails\r\n\r\n    private val _yugiohProductDetails = MutableLiveData<Event<State<YugiohDomainModel>>>()\r\n    val yugiohProductDetails: LiveData<Event<State<YugiohDomainModel>>>\r\n        get() = _yugiohProductDetails\r\n\r\n    private val _sealedProductDetails = MutableLiveData<Event<State<SealedDomainModel>>>()\r\n    val sealedProductDetails: LiveData<Event<State<SealedDomainModel>>>\r\n        get() = _sealedProductDetails\r\n\r\n    private val _funkoProductDetails = MutableLiveData<Event<State<FunkoDomainModel>>>()\r\n    val funkoProductDetails: LiveData<Event<State<FunkoDomainModel>>>\r\n        get() = _funkoProductDetails\r\n\r\n    fun getProductDetails(id: String, type: ProductType) {\r\n        viewModelScope.launch {\r\n            when (type) {\r\n                ProductType.MAGIC_THE_GATHERING -> repository.getProductDetails<MTGDomainModel>(\r\n                    id,\r\n                    ProductType.MAGIC_THE_GATHERING\r\n                ).collect {\r\n                    _mtgProductDetails.value = Event(it)\r\n                }\r\n                ProductType.YUGIOH -> repository.getProductDetails<YugiohDomainModel>(\r\n                    id,\r\n                    ProductType.YUGIOH\r\n                ).collect {\r\n                    _yugiohProductDetails.value = Event(it)\r\n                }\r\n                ProductType.POKEMON -> repository.getProductDetails<PokemonDomainModel>(\r\n                    id,\r\n                    ProductType.POKEMON\r\n                ).collect {\r\n                    _pokemonProductDetails.value = Event(it)\r\n                }\r\n                ProductType.FUNKO -> repository.getProductDetails<FunkoDomainModel>(\r\n                    id,\r\n                    ProductType.FUNKO\r\n                ).collect {\r\n                    _funkoProductDetails.value = Event(it)\r\n                }\r\n                ProductType.SEALED_POKEMON -> repository.getProductDetails<SealedDomainModel>(\r\n                    id,\r\n                    ProductType.SEALED_POKEMON\r\n                ).collect {\r\n                    _sealedProductDetails.value = Event(it)\r\n                }\r\n                ProductType.SEALED_YUGIOH -> repository.getProductDetails<SealedDomainModel>(\r\n                    id,\r\n                    ProductType.SEALED_YUGIOH\r\n                ).collect {\r\n                    _sealedProductDetails.value = Event(it)\r\n                }\r\n                ProductType.SEALED_MTG -> repository.getProductDetails<SealedDomainModel>(\r\n                    id,\r\n                    ProductType.SEALED_MTG\r\n                ).collect {\r\n                    _sealedProductDetails.value = Event(it)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fun getShippingTierInfo(tier: String) {\r\n        shippingTierJob?.cancel()\r\n        shippingTierJob = viewModelScope.launch {\r\n            repository.getShippingTierInfo(tier).collect {\r\n                _shippingTierInfo.value = Event(it)\r\n            }\r\n        }\r\n    }\r\n\r\n    fun setStaticShippingInfo() {\r\n        _shippingTierInfo.value = Event(\r\n            State.success(\r\n                ShippingInfoDomainModel(\r\n                    billing = 0,\r\n                    frontEndShippingProcessing = \"0.5\",\r\n                    service = \"\",\r\n                    refKey = null\r\n                )\r\n            )\r\n        )\r\n    }\r\n\r\n    fun retrieveLanguageList(type: ProductType) {\r\n        viewModelScope.launch {\r\n            _languageList.value = when (type) {\r\n                ProductType.POKEMON -> Event(getPokemonLangList((pokemonProductDetails.value!!.peekContent() as State.Success).data))\r\n                ProductType.YUGIOH -> Event(getYugiohLangList((yugiohProductDetails.value!!.peekContent() as State.Success).data))\r\n                ProductType.MAGIC_THE_GATHERING -> Event(getMTGLangList())\r\n                else -> Event(listOf())\r\n            }\r\n        }\r\n    }\r\n\r\n    fun retrieveEditionList(type: ProductType) {\r\n        viewModelScope.launch {\r\n            _editionList.value = when (type) {\r\n                ProductType.POKEMON ->\r\n                    Event(\r\n                        getPokemonEditionList(\r\n                            getPokemonEditionKey(\r\n                                selectedLanguage.value!!.peekContent().key,\r\n                                (pokemonProductDetails.value!!.peekContent() as State.Success).data\r\n                            )\r\n                        )\r\n                    )\r\n                ProductType.YUGIOH ->\r\n                    Event(\r\n                        getYugiohEditionList(\r\n                            getYugiohEditionKey(\r\n                                selectedLanguage.value!!.peekContent().key,\r\n                                (yugiohProductDetails.value!!.peekContent() as State.Success).data\r\n                            )\r\n                        )\r\n                    )\r\n                ProductType.MAGIC_THE_GATHERING ->\r\n                    Event(getMTGEditionList())\r\n                else -> Event(listOf())\r\n            }\r\n        }\r\n    }\r\n\r\n    fun retrieveConditionList(type: ConditionType) {\r\n        viewModelScope.launch {\r\n            _conditionList.value = Event(getConditionList(type))\r\n        }\r\n    }\r\n\r\n\r\n    var mFrontImageDownloadUrl = \"\"\r\n        private set\r\n\r\n    var mBackImageDownloadUrl = \"\"\r\n        private set\r\n\r\n    //Collection Item key use to store image in firebase Storage in collectionImage folder\r\n    var mCollectionKey = \"\"\r\n        private set\r\n\r\n    var mAskId = \"\"\r\n       private set\r\n\r\n    var mAddress : ShippingAddressDomainModel? = null\r\n        private set\r\n\r\n    var mBidId = \"\"\r\n        private set\r\n\r\n    var mBuyKey = \"\"\r\n        private set\r\n\r\n    fun setBidId(id : String){\r\n        mBidId = id\r\n    }\r\n\r\n    fun setBuyKey(key : String){\r\n        mBuyKey = key\r\n    }\r\n\r\n    fun setFrontImageDownloadUrl(url : String){\r\n        mFrontImageDownloadUrl = url\r\n    }\r\n\r\n    fun setBackImageDownloadUrl(url : String){\r\n        mBackImageDownloadUrl = url\r\n    }\r\n\r\n    fun setCollectionKey(key : String){\r\n        mCollectionKey = key\r\n    }\r\n\r\n    fun setAskId(key : String){\r\n        mAskId = key\r\n    }\r\n\r\n    fun setAddress(address : ShippingAddressDomainModel){\r\n        mAddress = address\r\n    }\r\n\r\n\r\n\r\n    //Variable to indicate whether Collection data has been added in Firebase\r\n    private val _insertCollectionRDB = MutableLiveData<Event<State<String>>>()\r\n    val insertCollectionRDB: LiveData<Event<State<String>>>\r\n        get() = _insertCollectionRDB\r\n\r\n    fun insertCollection(){\r\n        viewModelScope.launch {\r\n            val data : CollectionItemDomainModel? = when(productType){\r\n                ProductType.MAGIC_THE_GATHERING,ProductType.YUGIOH,ProductType.POKEMON -> {\r\n                    CollectionItemDomainModel(\r\n                        marketCost = 0.0,\r\n                        productType = productType,\r\n                        edition = selectedEdition.value?.peekContent(),frontImageURL = null,\r\n                        backImageURL = null,askRefKey = null,\r\n                        id = null,itemRefKey = null,language = selectedLanguage.value?.peekContent(),\r\n                        condition = selectedCondition.value?.peekContent(),\r\n                        objectID = productDisplayModel?.objectID\r\n                    )\r\n                }\r\n                ProductType.FUNKO,ProductType.SEALED_POKEMON,ProductType.SEALED_YUGIOH,ProductType.SEALED_MTG -> {\r\n                    CollectionItemDomainModel(\r\n                        marketCost = 0.0,\r\n                        productType = productType,\r\n                        edition = null,frontImageURL = null,\r\n                        backImageURL = null,askRefKey = null,\r\n                        id = null,itemRefKey = null,language = null,\r\n                        condition = null,\r\n                        objectID = productDisplayModel?.objectID\r\n                    )\r\n                }\r\n                null -> null\r\n            }\r\n            repository.insertCollection(GthrCollect.prefs?.getUserCollectionId()!!,data?.toRealtimeDatabaseModel()!!).collect {\r\n                _insertCollectionRDB.value = Event(it)\r\n            }\r\n        }\r\n    }\r\n\r\n    //Variable to indicate whether Collection data has been updated in Firebase\r\n    private val _updateCollectionRDB = MutableLiveData<Event<State<Boolean>>>()\r\n    val updateCollectionRDB: LiveData<Event<State<Boolean>>>\r\n        get() = _updateCollectionRDB\r\n\r\n    fun updateCollection(){\r\n        viewModelScope.launch {\r\n            repository.updateCollection(GthrCollect.prefs?.getUserCollectionId()!!,mCollectionKey,mFrontImageDownloadUrl,mBackImageDownloadUrl,mAskId).collect {\r\n                _updateCollectionRDB.value = Event(it)\r\n            }\r\n        }\r\n    }\r\n\r\n    //Variable to indicate whether user front Id image uploaded\r\n    private val _frontImageUpload = MutableLiveData<Event<State<String>>>()\r\n    val frontImageUpload: LiveData<Event<State<String>>>\r\n        get() = _frontImageUpload\r\n\r\n    fun uploadFrontImage() {\r\n        viewModelScope.launch {\r\n            repository.uploadCollectionImage(frontImageUrl.value!!,mCollectionKey,FirebaseStorage.FRONT_IMAGE, GthrCollect.prefs!!.signedInUser!!.uid).collect {\r\n                _frontImageUpload.value = Event(it)\r\n            }\r\n        }\r\n    }\r\n\r\n    //Variable to indicate whether user back Id image uploaded\r\n    private val _backImageUpload = MutableLiveData<Event<State<String>>>()\r\n    val backImageUpload: LiveData<Event<State<String>>>\r\n        get() = _backImageUpload\r\n\r\n    fun uploadBackImage() {\r\n       viewModelScope.launch {\r\n            repository.uploadCollectionImage(backImageUrl.value!!,mCollectionKey,FirebaseStorage.BACK_IMAGE,GthrCollect.prefs!!.signedInUser!!.uid).collect {\r\n                _backImageUpload.value = Event(it)\r\n            }\r\n        }\r\n    }\r\n\r\n    //Variable to indicate whether Ask data has been added in Firebase\r\n    private val _insertAskRDB = MutableLiveData<Event<State<String>>>()\r\n    val insertAskRDB: LiveData<Event<State<String>>>\r\n        get() = _insertAskRDB\r\n\r\n    fun insertAsk(){\r\n        viewModelScope.launch {\r\n           val data = when(productType){\r\n                ProductType.MAGIC_THE_GATHERING,ProductType.YUGIOH,ProductType.POKEMON -> {\r\n                    AskItemDomainModel(\r\n                        refKey = \"\",duration = \"\",itemRefKey = \"\",\r\n                        creatorUID = GthrCollect.prefs?.signedInUser?.uid!!,\r\n                        askPrice = askPrice.value.toString(),\r\n                        totalPayout = totalPayoutRate.toString(),\r\n                        itemObjectID = productDisplayModel?.objectID!!,\r\n                        productType = productType,\r\n                        productCategory = getProductCategory(productType!!),\r\n                        edition = selectedEdition.value?.peekContent(),\r\n                        condition = selectedCondition.value?.peekContent(),\r\n                        language = selectedLanguage.value?.peekContent(),\r\n                        returnName = mAddress?.firstName, returnAddressLine1 = mAddress?.addressLine1, returnAddressLine2 = mAddress?.addressLine2,\r\n                        returnCity = mAddress?.city, returnState = mAddress?.state, returnZipCode = mAddress?.postalCode,\r\n                        returnCountry = mAddress?.country, frontImageURL = null, backImageURL = null\r\n                    )\r\n                }\r\n                ProductType.FUNKO,ProductType.SEALED_POKEMON,ProductType.SEALED_YUGIOH,ProductType.SEALED_MTG -> {\r\n                    AskItemDomainModel(\r\n                        refKey = \"\",duration = \"\",itemRefKey = productDisplayModel?.refKey!!,\r\n                        creatorUID = GthrCollect.prefs?.signedInUser?.uid!!,\r\n                        askPrice = askPrice.value.toString(),\r\n                        totalPayout = totalPayoutRate.toString(),\r\n                        itemObjectID = productDisplayModel?.objectID!!,\r\n                        productType = productType,\r\n                        productCategory = getProductCategory(productType!!),\r\n                        edition = null, condition = null, language = null,\r\n                        returnName = mAddress?.firstName, returnAddressLine1 = mAddress?.addressLine1, returnAddressLine2 = mAddress?.addressLine2,\r\n                        returnCity = mAddress?.city, returnState = mAddress?.state, returnZipCode = mAddress?.postalCode,\r\n                        returnCountry = mAddress?.country, frontImageURL = null, backImageURL = null,\r\n                    )\r\n                }\r\n               else -> null\r\n           }\r\n            repository.insertAsk(data?.toRealtimeDatabaseModel()!!).collect {\r\n                _insertAskRDB.value = Event(it)\r\n            }\r\n        }\r\n    }\r\n\r\n    //Variable to indicate whether Product data has been updated in Firebase\r\n    private val _updateProductForAskRDB = MutableLiveData<Event<State<Boolean>>>()\r\n    val updateProductForAskRDB: LiveData<Event<State<Boolean>>>\r\n        get() = _updateProductForAskRDB\r\n\r\n    fun updateProductForAsk(){\r\n        viewModelScope.launch {\r\n            GthrLogger.i(\"shdbchjsdb\", \"productType:  $productType}\")\r\n            GthrLogger.i(\"shdbchjsdb\", \"productDisplayModel?.refKey: ${productDisplayModel?.refKey}\")\r\n            repository.updateProductForAsk(askPrice.value!!.toInt(),mAskId,productType!!,productDisplayModel?.refKey!!,productDisplayModel?.objectID!!).collect {\r\n                _updateProductForAskRDB.value = Event(it)\r\n            }\r\n        }\r\n    }\r\n\r\n    //==========Bid===========\r\n\r\n    //Variable to indicate whether Bid data has been added in Firebase\r\n    private val _insertBidRDB = MutableLiveData<Event<State<String>>>()\r\n    val insertBidRDB: LiveData<Event<State<String>>>\r\n        get() = _insertBidRDB\r\n\r\n    fun insertBid(){\r\n        viewModelScope.launch {\r\n            val data = BidItemDomainModel(\r\n                bidPrice = buyListPrice.value.toString(),\r\n                creatorUID = GthrCollect.prefs?.signedInUser?.uid!!,\r\n                itemObjectID =  productDisplayModel?.objectID!!,\r\n                productType = productType,\r\n                productCategory = getProductCategory(productType!!),\r\n                itemRefKey = productDisplayModel?.refKey,\r\n                totalCost = buyListPrice.value.toString()\r\n            )\r\n            repository.insertBid(data.toRealtimeDatabaseModel()).collect {\r\n                _insertBidRDB.value = Event(it)\r\n            }\r\n        }\r\n    }\r\n\r\n    //Variable to indicate whether Buy data has been added in Firebase\r\n    private val _insertBuyRDB = MutableLiveData<Event<State<String>>>()\r\n    val insertBuyRDB: LiveData<Event<State<String>>>\r\n        get() = _insertBuyRDB\r\n\r\n    fun insertBuy(){\r\n        viewModelScope.launch {\r\n            repository.insertBuy(GthrCollect.prefs?.getUserCollectionId()!!,mBidId).collect {\r\n                _insertBuyRDB.value = Event(it)\r\n            }\r\n        }\r\n    }\r\n\r\n    //Variable to indicate whether Product data has been updated in Firebase\r\n    private val _updateProductForBidRDB = MutableLiveData<Event<State<Boolean>>>()\r\n    val updateProductForBidRDB: LiveData<Event<State<Boolean>>>\r\n        get() = _updateProductForBidRDB\r\n\r\n    fun updateProductForBid(){\r\n        viewModelScope.launch {\r\n            GthrLogger.i(\"shdbchjsdb\", \"productType:  $productType}\")\r\n            GthrLogger.i(\"shdbchjsdb\", \"productDisplayModel?.refKey: ${productDisplayModel?.refKey}\")\r\n            repository.updateProductForBid(buyListPrice.value?.toInt()!!,mBidId,productType!!,productDisplayModel?.refKey!!,productDisplayModel?.objectID!!).collect {\r\n                _updateProductForBidRDB.value = Event(it)\r\n            }\r\n        }\r\n    }\r\n\r\n    override fun onCleared() {\r\n        super.onCleared()\r\n        shippingTierJob?.cancel()\r\n    }\r\n\r\n    companion object {\r\n        private const val PERCENT_SELLING_FEE = 8.5f\r\n        private const val PERCENT_PAYMENT_PROCESSING = 2.9f\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/gthr/gthrcollect/ui/askflow/AskFlowViewModel.kt b/app/src/main/java/com/gthr/gthrcollect/ui/askflow/AskFlowViewModel.kt
--- a/app/src/main/java/com/gthr/gthrcollect/ui/askflow/AskFlowViewModel.kt	(revision 5afe8ae07915a360cc92d45e0a46d20d1c6c84e4)
+++ b/app/src/main/java/com/gthr/gthrcollect/ui/askflow/AskFlowViewModel.kt	(date 1632406327081)
@@ -390,7 +390,7 @@
                         marketCost = 0.0,
                         productType = productType,
                         edition = selectedEdition.value?.peekContent(),frontImageURL = null,
-                        backImageURL = null,askRefKey = null,
+                        backImageURL = null,askRefKey = productDisplayModel?.refKey,
                         id = null,itemRefKey = null,language = selectedLanguage.value?.peekContent(),
                         condition = selectedCondition.value?.peekContent(),
                         objectID = productDisplayModel?.objectID
@@ -401,7 +401,7 @@
                         marketCost = 0.0,
                         productType = productType,
                         edition = null,frontImageURL = null,
-                        backImageURL = null,askRefKey = null,
+                        backImageURL = null,askRefKey = productDisplayModel?.refKey,
                         id = null,itemRefKey = null,language = null,
                         condition = null,
                         objectID = productDisplayModel?.objectID
@@ -464,7 +464,7 @@
            val data = when(productType){
                 ProductType.MAGIC_THE_GATHERING,ProductType.YUGIOH,ProductType.POKEMON -> {
                     AskItemDomainModel(
-                        refKey = "",duration = "",itemRefKey = "",
+                        refKey = "",duration = "",itemRefKey = productDisplayModel?.refKey!!,
                         creatorUID = GthrCollect.prefs?.signedInUser?.uid!!,
                         askPrice = askPrice.value.toString(),
                         totalPayout = totalPayoutRate.toString(),
